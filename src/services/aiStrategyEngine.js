\nimport { collection, getDocs, doc, setDoc, Timestamp } from \'firebase/firestore\';\nimport { db } from \'../firebase\';\n\n// --- CORE ANALYSIS FUNCTIONS ---\n\n/**\n * Calculates the win rate from a series of rounds.\n * @param {Array<object>} rounds - Array of round objects.\n * @returns {number} The win rate as a percentage.\n */\nconst calculateWinRate = (rounds) => {\n    if (rounds.length === 0) return 0;\n    const wins = rounds.filter(r => r.outcome === \'win\').length;\n    return (wins / rounds.length) * 100;\n};\n\n/**\n * Calculates the average multiplier for winning rounds.\n * @param {Array<object>} rounds - Array of round objects.\n * @returns {number} The average cash-out multiplier for wins.\n */\nconst calculateAvgMultiplier = (rounds) => {\n    const winningRounds = rounds.filter(r => r.outcome === \'win\');\n    if (winningRounds.length === 0) return 0;\n    const totalMultiplier = winningRounds.reduce((sum, r) => sum + r.cashOutMultiplier, 0);\n    return totalMultiplier / winningRounds.length;\n};\n\n/**\n * Calculates the ratio of the average win amount to the average loss amount.\n * @param {Array<object>} rounds - Array of round objects.\n * @returns {number} The risk/reward ratio.\n */\nconst calculateRiskReward = (rounds) => {\n    const wins = rounds.filter(r => r.outcome === \'win\');\n    const losses = rounds.filter(r => r.outcome === \'loss\');\n    if (losses.length === 0) return wins.length > 0 ? 100 : 0; // Infinite reward if no losses\n    if (wins.length === 0) return 0;\n    const avgWin = wins.reduce((sum, r) => sum + r.profit, 0) / wins.length;\n    const avgLoss = Math.abs(losses.reduce((sum, r) => sum + r.profit, 0) / losses.length);\n    return avgWin / avgLoss;\n};\n\n/**\n * Calculates the consistency of profits using the standard deviation relative to the average bet size.\n * A lower score means more volatile profits, a higher score means more consistent profits.\n * @param {Array<object>} rounds - Array of round objects.\n * @returns {number} A consistency score from 0 to 100.\n */\nconst calculateProfitConsistency = (rounds) => {\n    if (rounds.length < 2) return 50; // Neutral score for insufficient data\n    const profits = rounds.map(r => r.profit);\n    const meanProfit = profits.reduce((sum, p) => sum + p, 0) / profits.length;\n    const variance = profits.reduce((sum, p) => sum + Math.pow(p - meanProfit, 2), 0) / profits.length;\n    const stdDev = Math.sqrt(variance);\n\n    const avgBet = rounds.reduce((sum, r) => sum + r.amount, 0) / rounds.length;\n    if (avgBet === 0) return 50;\n\n    // Normalize the score. A lower std dev relative to bet size is better.\n    const relativeStdDev = stdDev / avgBet;\n    const score = 100 - (relativeStdDev * 50); // Scale the score\n\n    return Math.max(0, Math.min(100, score)); // Clamp between 0 and 100\n};\n\n/**\n * Calculates the longest streak of consecutive losses.\n * @param {Array<object>} rounds - Chronologically sorted array of round objects.\n * @returns {number} The maximum number of consecutive losses.\n */\nconst calculateMaxLossStreak = (rounds) => {\n    let maxStreak = 0;\n    let currentStreak = 0;\n    for (const round of rounds) {\n        if (round.outcome === \'loss\') {\n            currentStreak++;\n        } else {\n            if (currentStreak > maxStreak) {\n                maxStreak = currentStreak;\n            }\n            currentStreak = 0;\n        }\n    }\n    // Final check in case the streak is at the very end\n    if (currentStreak > maxStreak) {\n        maxStreak = currentStreak;\n    }\n    return maxStreak;\n};\n\n/**\n * Detects patterns of \"revenge betting\" - significantly increasing bet size after a loss.\n * @param {Array<object>} rounds - Chronologically sorted array of round objects.\n * @returns {number} A score from 0 to 100 indicating the likelihood of revenge betting.\n */\nconst detectRevengeBetting = (rounds) => {\n    let revengeScore = 0;\n    for (let i = 1; i < rounds.length; i++) {\n        if (rounds[i - 1].outcome === \'loss\' && rounds[i].amount > rounds[i - 1].amount * 1.5) {\n            revengeScore += 20; // Add points for each detected instance\n        }\n    }\n    return Math.min(revengeScore, 100);\n};\n\n/**\n * Correlates emotional bias scores from mindset entries with trading performance.\n * @param {Array<object>} rounds - Array of round objects.\n * @param {Array<object>} mindsetEntries - Array of mindset entries.\n * @returns {number} An aggregated emotional bias score impacting performance.\n */\nconst analyzeEmotionalCorrelation = (rounds, mindsetEntries) => {\n    if (mindsetEntries.length === 0) return 50; // Neutral score if no data\n    const latestMindset = mindsetEntries[0]; // Assuming entries are sorted desc\n    return latestMindset.emotionalBiasScore;\n};\n\n/**\n * Analyzes the profitability of different multiplier ranges.\n * @param {Array<object>} rounds - Array of round objects.\n * @returns {string} The most profitable multiplier range as a string (e.g., \"1.5x-2.0x\").\n */\nconst findBestRange = (rounds) => {\n    const ranges = { \"1.1-1.5x\": 0, \"1.5-2.0x\": 0, \"2.0-3.0x\": 0, \"3.0x+\": 0 };\n    rounds.filter(r => r.outcome === \'win\').forEach(r => {\n        if (r.cashOutMultiplier <= 1.5) ranges[\"1.1-1.5x\"] += r.profit;\n        else if (r.cashOutMultiplier <= 2.0) ranges[\"1.5-2.0x\"] += r.profit;\n        else if (r.cashOutMultiplier <= 3.0) ranges[\"2.0-3.0x\"] += r.profit;\n        else ranges[\"3.0x+\"] += r.profit;\n    });\n    return Object.keys(ranges).reduce((a, b) => ranges[a] > ranges[b] ? a : b);\n};\n\n/**\n * Generates a concise AI comment based on the primary detected pattern.\n * @param {object} analytics - The calculated analytics object.\n * @returns {string} A short, actionable comment.\n */\nconst generateAiComment = (analytics) => {\n    if (analytics.lossStreaks > 5) {\n        return `A loss streak of ${analytics.lossStreaks} is high. Review your risk management and consider a break.\`;\n    }\n    if (analytics.emotionalBiasScore > 75) {\n        return \"High emotional bias detected. Focus on detaching from outcomes.\";\n    }\n    if (analytics.winRate < 40) {\n        return \"Win rate is low. Consider lowering your risk or reviewing your entry points.\";\n    }\n    if (analytics.riskRewardRatio < 1) {\n        return \"Your risk/reward is unfavorable. Aim for larger wins or smaller losses.\";\n    }\n    return \"Performance is stable. Continue executing your strategy with discipline.\";\n};\n\n// --- MAIN EXPORTED FUNCTION ---\n\n/**\n * The main function to analyze a user\'s performance data.\n * It fetches all necessary data, runs calculations, and stores the result.\n * @param {string} userId - The ID of the user to analyze.\n */\nexport const analyzeUserPerformance = async (userId) => {\n    try {\n        // 1. Fetch Data\n        const roundsRef = collection(db, `users/${userId}/rounds`);\n        const mindsetRef = collection(db, `users/${userId}/mindset`);\n\n        const [roundsSnapshot, mindsetSnapshot] = await Promise.all([\n            getDocs(roundsRef),\n            getDocs(mindsetRef),\n        ]);\n\n        const rounds = roundsSnapshot.docs\n            .map(doc => ({ id: doc.id, ...doc.data() }))\n            .sort((a, b) => a.timestamp.toMillis() - b.timestamp.toMillis()); // Sort chronological\n\n        const mindsetEntries = mindsetSnapshot.docs\n            .map(doc => ({ id: doc.id, ...doc.data() }))\n            .sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis()); // Sort reverse-chronological\n\n        if (rounds.length < 5) {\n            console.log(\"Not enough data to analyze.\");\n            return;\n        }\n\n        // 2. Calculate Metrics\n        const winRate = calculateWinRate(rounds);\n        const avgMultiplier = calculateAvgMultiplier(rounds);\n        const riskRewardRatio = calculateRiskReward(rounds);\n        const bestRange = findBestRange(rounds);\n        const revengeBettingScore = detectRevengeBetting(rounds);\n        const emotionalBiasScore = analyzeEmotionalCorrelation(rounds, mindsetEntries);\n        const profitConsistencyScore = calculateProfitConsistency(rounds);\n        const lossStreaks = calculateMaxLossStreak(rounds);\n\n        // Combine scores into a performance summary\n        const performanceSummary = `You show consistency in the ${bestRange} range, but a ${revengeBettingScore}% revenge betting score and a ${emotionalBiasScore}% emotional bias suggest decisions are sometimes emotionally driven.`;\n        const aiSuggestion = revengeBettingScore > 50 ? \"Take a 5-minute break after every 2 consecutive losses to reset.\" : \"Your strategy is solid. Focus on maintaining discipline during drawdowns.\";\n\n        const analyticsData = {\n            winRate,\n            avgMultiplier,\n            riskRewardRatio,\n            bestRange,\n            profitConsistencyScore,\n            lossStreaks,\n            emotionalBiasScore,\n            performanceSummary,\n            aiSuggestion,\n        };\n\n        const aiComment = generateAiComment(analyticsData);\n\n        const finalResult = {\n            ...analyticsData,\n            aiComment,\n            lastAnalyzed: Timestamp.now(),\n        };\n\n        // 3. Store Result\n        const analyticsDocRef = doc(db, `users/${userId}/analytics`, \'latest\');\n        await setDoc(analyticsDocRef, finalResult);\n\n        console.log(`Successfully analyzed performance for user ${userId}`);\n\n    } catch (error) {\n        console.error(\"Error in AI Strategy Engine: \", error);\n    }\n};\n\nexport default analyzeUserPerformance;\n